<html>
  <head>
    <script src="../simid_protocol.js"> </script>
    <script src="base_simid_creative.js"> </script>
    <script src="banner_nonlinear.js"> </script>
  </head>
  <style>
    #close_ad {
      color: red;
      border: solid white 1px;
      font-size: 14;
      float: right;
    }
    #minimize_ad {
      color:rgb(78, 78, 78);
      border: solid white 1px;
      font-size: 14;
      float: right;
    }
    button {
      cursor: pointer;
    }
    body {
      background: rgba(0,0,0,0.5);
      width: auto;
      text-align: center;
      transition: opacity .5s cubic-bezier(0.0,0.0,0.2,1);
      text-shadow: 0 0 4px rgba(0,0,0,0.75);
      cursor: pointer;
    }
    body:hover {
      background: rgba(0,0,0,0.7);
    }
    #ad_text {
      color: white;
      text-align: center;
    }
  </style>
  <body>
    <button id="close_ad">X</button>
    <button id="minimize_ad">_</button>
    <div id="content_container">
      <h1 id="ad_text">This is a banner ad</h1>
      <div id="content_box" class="hidden">
        <canvas id="drawing_area" width="600" height="400"></canvas>
      </div>
    </div>
    <script>
      //The creative should first call ready
      const bannerNonLinear = new BannerNonLinear();
      // This implementation is immediately ready but other creatives
      // may wish to wait for assets to load before calling ready.
      bannerNonLinear.ready();

      class DrawingTool {
        constructor() {
          this.previousX_ = 0;
          this.previousY_ = 0;
          this.function_ = (event) => this.onMouseMove_(event);
        }
        
        setupCanvasAndListeners() {
          let canvas = document.getElementById("drawing_area");
          canvas.style.cursor = 'crosshair';
          canvas.style.borderStyle = 'solid';
          let context = canvas.getContext('2d');
          context.strokeStyle = 'rgb(255,255,255)';
          context.lineWidth = 4;
          canvas.addEventListener('mousedown', (event) => this.onMouseDown_(event));
          canvas.addEventListener('mouseup', (event) => this.onMouseUp_(event));
        }

        getMousePos_(canvas, evt) {
          var rect = canvas.getBoundingClientRect();
          return {
            x: (evt.clientX - rect.left) / (rect.right - rect.left) * canvas.width,
            y: (evt.clientY - rect.top) / (rect.bottom - rect.top) * canvas.height
        };
        }

        onMouseDown_(event) {
          let canvas = document.getElementById('drawing_area');
          const mousePos = this.getMousePos_(canvas, event);
          this.previousX_ = mousePos.x;
          this.previousY_ = mousePos.y;
          canvas.addEventListener('mousemove', this.function_);
        }

        onMouseUp_(event) {
          let canvas = document.getElementById('drawing_area');
          canvas.removeEventListener('mousemove', this.function_);
        }

        onMouseMove_(event) {
          let canvas = document.getElementById('drawing_area');
          let context = canvas.getContext('2d');
          const mousePos = this.getMousePos_(canvas, event);
          const newX = mousePos.x;
          const  newY = mousePos.y;   
          context.beginPath();
          context.moveTo(this.previousX_, this.previousY_);
          context.lineTo(newX, newY);
          context.stroke();
          this.previousX_ = newX;
          this.previousY_ = newY;
        }
      }
      let drawingTool = new DrawingTool();
      drawingTool.setupCanvasAndListeners();
    </script>
  </body>
</html>